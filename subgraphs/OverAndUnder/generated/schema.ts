// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class OverAndUnderGame extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OverAndUnderGame entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OverAndUnderGame must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OverAndUnderGame", id.toString(), this);
    }
  }

  static load(id: string): OverAndUnderGame | null {
    return changetype<OverAndUnderGame | null>(
      store.get("OverAndUnderGame", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get gameId(): BigInt {
    let value = this.get("gameId");
    return value!.toBigInt();
  }

  set gameId(value: BigInt) {
    this.set("gameId", Value.fromBigInt(value));
  }

  get startGameTimestamp(): BigInt {
    let value = this.get("startGameTimestamp");
    return value!.toBigInt();
  }

  set startGameTimestamp(value: BigInt) {
    this.set("startGameTimestamp", Value.fromBigInt(value));
  }

  get endGameTimestamp(): BigInt {
    let value = this.get("endGameTimestamp");
    return value!.toBigInt();
  }

  set endGameTimestamp(value: BigInt) {
    this.set("endGameTimestamp", Value.fromBigInt(value));
  }

  get minBet(): BigInt {
    let value = this.get("minBet");
    return value!.toBigInt();
  }

  set minBet(value: BigInt) {
    this.set("minBet", Value.fromBigInt(value));
  }

  get maxBet(): BigInt {
    let value = this.get("maxBet");
    return value!.toBigInt();
  }

  set maxBet(value: BigInt) {
    this.set("maxBet", Value.fromBigInt(value));
  }

  get initialMultiplier(): BigInt {
    let value = this.get("initialMultiplier");
    return value!.toBigInt();
  }

  set initialMultiplier(value: BigInt) {
    this.set("initialMultiplier", Value.fromBigInt(value));
  }

  get updateMulAfterAmountInWei(): BigInt {
    let value = this.get("updateMulAfterAmountInWei");
    return value!.toBigInt();
  }

  set updateMulAfterAmountInWei(value: BigInt) {
    this.set("updateMulAfterAmountInWei", Value.fromBigInt(value));
  }

  get curUpdateMulAtAmountInWei(): BigInt {
    let value = this.get("curUpdateMulAtAmountInWei");
    return value!.toBigInt();
  }

  set curUpdateMulAtAmountInWei(value: BigInt) {
    this.set("curUpdateMulAtAmountInWei", Value.fromBigInt(value));
  }

  get isGameDraw(): boolean {
    let value = this.get("isGameDraw");
    return value!.toBoolean();
  }

  set isGameDraw(value: boolean) {
    this.set("isGameDraw", Value.fromBoolean(value));
  }

  get stockId(): Bytes {
    let value = this.get("stockId");
    return value!.toBytes();
  }

  set stockId(value: Bytes) {
    this.set("stockId", Value.fromBytes(value));
  }

  get stockSymbol(): string {
    let value = this.get("stockSymbol");
    return value!.toString();
  }

  set stockSymbol(value: string) {
    this.set("stockSymbol", Value.fromString(value));
  }

  get predictPrice(): BigInt {
    let value = this.get("predictPrice");
    return value!.toBigInt();
  }

  set predictPrice(value: BigInt) {
    this.set("predictPrice", Value.fromBigInt(value));
  }

  get finalPrice(): BigInt | null {
    let value = this.get("finalPrice");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set finalPrice(value: BigInt | null) {
    if (!value) {
      this.unset("finalPrice");
    } else {
      this.set("finalPrice", Value.fromBigInt(<BigInt>value));
    }
  }

  get finalResult(): boolean {
    let value = this.get("finalResult");
    return value!.toBoolean();
  }

  set finalResult(value: boolean) {
    this.set("finalResult", Value.fromBoolean(value));
  }

  get resultsUpdatedAsDraw(): boolean {
    let value = this.get("resultsUpdatedAsDraw");
    return value!.toBoolean();
  }

  set resultsUpdatedAsDraw(value: boolean) {
    this.set("resultsUpdatedAsDraw", Value.fromBoolean(value));
  }

  get rewardsDistributed(): boolean {
    let value = this.get("rewardsDistributed");
    return value!.toBoolean();
  }

  set rewardsDistributed(value: boolean) {
    this.set("rewardsDistributed", Value.fromBoolean(value));
  }

  get winners(): Array<Bytes> {
    let value = this.get("winners");
    return value!.toBytesArray();
  }

  set winners(value: Array<Bytes>) {
    this.set("winners", Value.fromBytesArray(value));
  }

  get totalBetAmountPooled(): BigInt {
    let value = this.get("totalBetAmountPooled");
    return value!.toBigInt();
  }

  set totalBetAmountPooled(value: BigInt) {
    this.set("totalBetAmountPooled", Value.fromBigInt(value));
  }

  get totalNumberOfBets(): BigInt {
    let value = this.get("totalNumberOfBets");
    return value!.toBigInt();
  }

  set totalNumberOfBets(value: BigInt) {
    this.set("totalNumberOfBets", Value.fromBigInt(value));
  }

  get individualBetsInOverUnder(): Array<BigInt> {
    let value = this.get("individualBetsInOverUnder");
    return value!.toBigIntArray();
  }

  set individualBetsInOverUnder(value: Array<BigInt>) {
    this.set("individualBetsInOverUnder", Value.fromBigIntArray(value));
  }

  get curMultiplierForOverUnder(): Array<BigInt> {
    let value = this.get("curMultiplierForOverUnder");
    return value!.toBigIntArray();
  }

  set curMultiplierForOverUnder(value: Array<BigInt>) {
    this.set("curMultiplierForOverUnder", Value.fromBigIntArray(value));
  }

  get bets(): Array<string> {
    let value = this.get("bets");
    return value!.toStringArray();
  }

  set bets(value: Array<string>) {
    this.set("bets", Value.fromStringArray(value));
  }
}

export class OverAndUnderBet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OverAndUnderBet entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OverAndUnderBet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OverAndUnderBet", id.toString(), this);
    }
  }

  static load(id: string): OverAndUnderBet | null {
    return changetype<OverAndUnderBet | null>(store.get("OverAndUnderBet", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get gameId(): BigInt {
    let value = this.get("gameId");
    return value!.toBigInt();
  }

  set gameId(value: BigInt) {
    this.set("gameId", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get startGameTimestamp(): BigInt {
    let value = this.get("startGameTimestamp");
    return value!.toBigInt();
  }

  set startGameTimestamp(value: BigInt) {
    this.set("startGameTimestamp", Value.fromBigInt(value));
  }

  get isDraw(): boolean {
    let value = this.get("isDraw");
    return value!.toBoolean();
  }

  set isDraw(value: boolean) {
    this.set("isDraw", Value.fromBoolean(value));
  }

  get better(): Bytes {
    let value = this.get("better");
    return value!.toBytes();
  }

  set better(value: Bytes) {
    this.set("better", Value.fromBytes(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get betAmount(): BigInt {
    let value = this.get("betAmount");
    return value!.toBigInt();
  }

  set betAmount(value: BigInt) {
    this.set("betAmount", Value.fromBigInt(value));
  }

  get multiplier(): BigInt {
    let value = this.get("multiplier");
    return value!.toBigInt();
  }

  set multiplier(value: BigInt) {
    this.set("multiplier", Value.fromBigInt(value));
  }

  get predictAsOver(): boolean {
    let value = this.get("predictAsOver");
    return value!.toBoolean();
  }

  set predictAsOver(value: boolean) {
    this.set("predictAsOver", Value.fromBoolean(value));
  }

  get winAmount(): BigInt | null {
    let value = this.get("winAmount");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set winAmount(value: BigInt | null) {
    if (!value) {
      this.unset("winAmount");
    } else {
      this.set("winAmount", Value.fromBigInt(<BigInt>value));
    }
  }

  get win(): boolean {
    let value = this.get("win");
    return value!.toBoolean();
  }

  set win(value: boolean) {
    this.set("win", Value.fromBoolean(value));
  }

  get bet(): string {
    let value = this.get("bet");
    return value!.toString();
  }

  set bet(value: string) {
    this.set("bet", Value.fromString(value));
  }
}

export class OverAndUnderBetter extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OverAndUnderBetter entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OverAndUnderBetter must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OverAndUnderBetter", id.toString(), this);
    }
  }

  static load(id: string): OverAndUnderBetter | null {
    return changetype<OverAndUnderBetter | null>(
      store.get("OverAndUnderBetter", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get gameIds(): Array<BigInt> {
    let value = this.get("gameIds");
    return value!.toBigIntArray();
  }

  set gameIds(value: Array<BigInt>) {
    this.set("gameIds", Value.fromBigIntArray(value));
  }

  get totalBetAmount(): BigInt {
    let value = this.get("totalBetAmount");
    return value!.toBigInt();
  }

  set totalBetAmount(value: BigInt) {
    this.set("totalBetAmount", Value.fromBigInt(value));
  }

  get totalWinAmont(): BigInt {
    let value = this.get("totalWinAmont");
    return value!.toBigInt();
  }

  set totalWinAmont(value: BigInt) {
    this.set("totalWinAmont", Value.fromBigInt(value));
  }
}

export class OverAndUnderFund extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OverAndUnderFund entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OverAndUnderFund must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OverAndUnderFund", id.toString(), this);
    }
  }

  static load(id: string): OverAndUnderFund | null {
    return changetype<OverAndUnderFund | null>(
      store.get("OverAndUnderFund", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get totalFundsSentToTreasury(): BigInt {
    let value = this.get("totalFundsSentToTreasury");
    return value!.toBigInt();
  }

  set totalFundsSentToTreasury(value: BigInt) {
    this.set("totalFundsSentToTreasury", Value.fromBigInt(value));
  }

  get totalFundsReceivedFromTreasury(): BigInt {
    let value = this.get("totalFundsReceivedFromTreasury");
    return value!.toBigInt();
  }

  set totalFundsReceivedFromTreasury(value: BigInt) {
    this.set("totalFundsReceivedFromTreasury", Value.fromBigInt(value));
  }
}

export class TotalOverAndUnderDetail extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TotalOverAndUnderDetail entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TotalOverAndUnderDetail must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TotalOverAndUnderDetail", id.toString(), this);
    }
  }

  static load(id: string): TotalOverAndUnderDetail | null {
    return changetype<TotalOverAndUnderDetail | null>(
      store.get("TotalOverAndUnderDetail", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get totalNumOfGames(): BigInt {
    let value = this.get("totalNumOfGames");
    return value!.toBigInt();
  }

  set totalNumOfGames(value: BigInt) {
    this.set("totalNumOfGames", Value.fromBigInt(value));
  }

  get totalBetAmountWagered(): BigInt {
    let value = this.get("totalBetAmountWagered");
    return value!.toBigInt();
  }

  set totalBetAmountWagered(value: BigInt) {
    this.set("totalBetAmountWagered", Value.fromBigInt(value));
  }

  get totalRewardsDistributed(): BigInt {
    let value = this.get("totalRewardsDistributed");
    return value!.toBigInt();
  }

  set totalRewardsDistributed(value: BigInt) {
    this.set("totalRewardsDistributed", Value.fromBigInt(value));
  }
}

export class StockInfo extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StockInfo entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StockInfo must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StockInfo", id.toString(), this);
    }
  }

  static load(id: string): StockInfo | null {
    return changetype<StockInfo | null>(store.get("StockInfo", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get stockId(): Bytes {
    let value = this.get("stockId");
    return value!.toBytes();
  }

  set stockId(value: Bytes) {
    this.set("stockId", Value.fromBytes(value));
  }

  get stockSymbol(): string {
    let value = this.get("stockSymbol");
    return value!.toString();
  }

  set stockSymbol(value: string) {
    this.set("stockSymbol", Value.fromString(value));
  }

  get numOfGames(): BigInt {
    let value = this.get("numOfGames");
    return value!.toBigInt();
  }

  set numOfGames(value: BigInt) {
    this.set("numOfGames", Value.fromBigInt(value));
  }
}
